declare module 'fz-search' {
  type AtLeast<T, K extends keyof T> = Partial<T> & Pick<T, K>

  /** Declaration file was generated by dts-gen; types then manually specified and extended */

  export = fz_search

  type sourceItem = Record<string, string | string[]> | string
  type sourceData = sourceItem[]
  interface searchResult {
    item: sourceItem
    score: number
    fields: string[]
    matchIndex: number
    subIndex: number
    sortKey: string
  }

  declare class fz_search {
    constructor(options: Options)

    keys: string[]

    $uiSource(): any

    /**
     * Add an item to search index AND source collection.
     * It'll use identify_item to find if the item already exist.
     * If identify_item is null (default), calling this method is append-only with no duplicate detection
     *
     * To update the source, it use the assumption that this.source and this.index can be synced
     * by array index. That assumption will be true if source is a plain array, and always updated by this library.
     * Feel free to set `should_update_source` to false to manually manage source collection.
     *
     * Keeping source in sync is important to allow to recompute index from source.
     * This will happens with certain setting changes.
     *
     *  @param {*} source_item - item to add to search index
     *  @param {boolean=} should_update_source - set to false to skip updating the source.
     */
    add(source_item: sourceItem, should_update_source: boolean): void

    /**
     * Given a SearchResult object, generate a new object that follow alias structure
     * @param {SearchResult} result
     * @return {*} aliased result
     */
    aliasResult(b: searchResult): any

    /**
     * Return a Debounced version of FuzzySearch.search.
     * New function signature allow to specific callback for different phase of the debounce.
     * De-bounce is adaptative, it will allow short burst and try to learn actual computation time.
     *
     * query: term to search
     * immediate_cb(results) : if search was done without filtering
     * suppress_cb(cached_results) : debounce has supressed the search, return cache of last result
     * finally_cb(results): if at least 1 supression occured, make a new search when debounce end and call this.
     *
     * @returns {function({string}, function({Array}), function({Array}), function({Array}))}
     */
    getInteractive(): (
      query: string,
      immediate_cb: (results: searchResult[]) => void,
      suppress_cb: (cached_results: searchResult[]) => void,
      finally_cb: (results: searchResult[]) => void
    ) => void

    /**
     * Given a SearchResult object, recover the value of the best matching field.
     * This is done on demand for display.
     *
     * @param {SearchResult} result
     * @return {string} original field
     */
    getMatchingField(b: searchResult): string

    /**
     * Highlight a string using query stored in a FuzzySearch object.
     * @param {string} str
     * @param {string=} field
     */
    highlight(b: string, c?: string): string

    /**
     * Score of "search a in b" using self as options.
     * @param  {string} a
     * @param {string} b
     */
    score(a: string, b: string): number

    // Search for a query string, return an array of SearchResult object.
    search(query: string): searchResult[] | any[]

    /**
     * Allow to change options after the object has been created.
     * If source is changed, new source is indexed.
     *
     * Optional reset allow to change any setting not in options to defaults.
     * This is similar to creating new object, but using same pointer.
     *
     * @param {Object} options
     * @param {boolean=} reset
     */

    setOptions(options: Options, reset?: boolean): void

    static align(b: any, c: any, d: any, e: any, f: any): any

    static alphabet(b: any): any

    static bitVector(a: any, b: any, c: any): any

    static filterGTE(a: any, b: any, c: any): any

    static filterSize(a: any, b: any, c: any): any

    static generateFields(a: any, b: any): any

    /**
     * Highlight string b, from searching a in it.
     *
     * @param {string} a - string to search
     * @param {string} b - string to highlight
     * @param {FuzzySearchOptions=} options
     *
     */
    static highlight(a: string, b: string, options: Options): any

    static llcs_large(a: any, b: any, c: any, d: any): any

    static map(a: any, b: any, c: any, d: any): any

    static mapAlphabet(b: any): any

    static mapField(a: any, b: any, c: any): any

    static matchTokens(b: any, c: any, d: any, e: any, f: any): any

    static pack_tokens(b: any): any

    static posVector(a: any): any

    /**
     * Score of "search a in b" using precomputed alphabet map
     * Main algorithm for single query token to score
     *
     * @param {string} a
     * @param {string} b
     * @param {Object} aMap - See FuzzySearch.alphabet
     * @param {FuzzySearchOptions} options
     */
    static score_map(a: string, b: string, d: any, options: Options): number

    static score_pack(b: any, c: any, d: any): any

    static score_single(b: any, c: any, d: any): any

    static setOptions(a: any, d: any, e: any, f: any, g: any, h: any): void
  }

  type Options = AtLeast<CompleteOptions, 'source'>

  interface CompleteOptions {
    // Additional value per character in common prefix
    bonus_match_start: number
    // Exponential decay for position bonus (smaller : more importance to first item)
    bonus_position_decay: number
    // Value of two token properly ordered
    bonus_token_order: number
    // If a field have this score, stop searching other fields. (field score is before item related bonus)
    field_good_enough: number

    // Select elements to be searched. (done before each search)
    filter: ((input_data: sourceData) => sourceData) | undefined

    // HTML tag to put before the highlighted part of the string
    highlight_after: string
    // HTML tag to put after the highlighted part of the string
    highlight_before: string
    // display small gap as substitution, set to size of gap, 0 to disable
    highlight_bridge_gap: number
    // true: force prefix as part of highlight, (false: minimum gap, slower)
    highlight_prefix: boolean
    // How to uniquely identify an item when adding to the index. Defaults to null, meaning no duplicate detection. Must be a method that takes a single (source) argument.
    identify_item: null | ((source: sourceItem) => string | null | number)
    // Allow short burst, prevent flicker due to debounce suppression of a callback
    interactive_burst: number
    // This is initial value for the debounce of an interactive search. Will try to learn actual time cost. Set to 0 to disable.
    interactive_debounce: number
    // Overhead for variability and to allow other things to happens (like redraw, highlight ).
    interactive_mult: number
    //String used to join array fields for indexing and searching
    join_str: string
    // When source is an array of objects, this contains the keys which should be searched. For example ['title', 'description'] or ['book.title', 'book.author']. Alternatively, supply an object which aliases keys to other keys, e.g. {title: 'book.title', author: 'book.author'}.
    keys: string[] | undefined | '' | string | Record<string, string>
    // when true, any refresh happens only when a user make a search, option stay put until changed.
    lazy: boolean
    // Minimum score to consider two token are not unrelated
    minimum_match: number
    // Return up to N result, 0 to disable
    output_limit: number
    /* Transform the output, can be a function or a path string.
      output_map="root" return SearchResult object, needed to see the score
      output_map="root.item" return original object.
      output_map="root.item.somefield" output a field of original object.
      (root.) is optional.
      output_map=function(root){ return something(root.item) }
      ^this get original object and apply something() on it.
    */
    output_map: string | ((root: searchResult) => any)
    // jrrt match against John Ronald Reuel Tolkien
    score_acronym: boolean
    /**
     * if true, split query&field in token, allow to match in different order
     * if false, bypass at least half the computation cost, very fast
     * also disable different token that score different field, because no more token!!
     */
    score_per_token: boolean
    // Two item that have the same rounded score are sorted alphabetically
    score_round: number
    // Try one extra match where we disregard token separation. - "oldman" match "old man"
    score_test_fused: boolean
    // Source data, which can either be a list of simple strings, or a list of objects. If it is a list of objects, the keys option must be set.
    source: sourceData
    // Maximum number of result to graduate from store, to the full search quality algorithm -Note that store only perform a crude search, ignoring some options, so the best result can be only "meh" here.
    store_max_results: number
    // cutoff point relative to best, to graduate from store phase.
    store_thresh: number
    // To be a candidate, score of item must be at least this
    thresh_include: number
    // and be at least this fraction of the best score
    thresh_relative_to_best: number
    // Shorten large token to give more even performance.
    token_field_max_length: number
    // include greater or equal, in item field
    token_field_min_length: number
    // Shorten large token to give more even performance.
    token_fused_max_length: number
    // Large field token tend to match against everything. Ensure query is long enough to be specific.
    token_max_rel_size: number
    // Field token should contain query token. Reject field token that are too small.
    token_min_rel_size: number
    // Shorten large token to give more even performance.
    token_query_max_length: number
    // Avoid processing very small words, include greater or equal, in query
    token_query_min_length: number
    //Separator string will be parsed to this re.
    token_re: RegExp

    token_sep: string
    // Enable a time vs memory trade-off for faster search (but longer initial warm-up).
    use_index_store: boolean

    // Function used to transform string (lowercase, accents, etc)
    normalize: (input: string) => string

    // Function used to sort the results returned by search, defaults to first score, and if score is equal, then alphabetically.
    sorter: (a: searchResult, b: searchResult) => number
  }
}
